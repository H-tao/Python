### 深入理解元类

内容参考书籍《流畅的Python》《Effective Python》《编写高质量代码：改善Python程序的91个建议》。

### 元类的定义

**元类是制造类的工厂，元类是用于构建类的类。**这句话很重要！！！这句话很重要！！！这句话很重要！！！

我们正常定义类是这样的：

```python
class Person(object):
    pass

class Child(Person):
    ClassName = 'Child'
    def __init__(self, name, age):
        if age > 20:
            raise ValueError("Child's age must small than 20")
        self._name = name
        self._age = age

    def speak(self):
        print(self._name, self._age)
```

我们还可以使用 type 来动态创建类：

```python
class Person(object):
    pass


ClassName = 'Child'
def __init__(self, name, age):
    if age > 20:
        raise ValueError("Child's age must small than 20")
    self._name = name
    self._age = age

def speak(self):
    print(self._name, self._age)

# type 的三个参数分别是 name、bases 和 dict。最后一个参数是一个映射，指定新类的属性名和值。
Child = type('Child', (Person,), {'ClassName': ClassName,
                                      '__init__': __init__,
                                      'speak': speak})
john = Child('John', 20)
john.speak()
print(Child.__dict__)  # 有 ClassName，__init__ 和 speak 属性
```

使用 type 关键字去拼接函数和属性来创建类，实在是不够优雅。之所以谈到这个，是为了方便我们后面理解元类是如何动态改变类的属性的。

### 区分继承自 type 和使用 metaclass 关键字

元类从 type 类继承了构建类的能力。所有类都直接或间接地是 type 的实例，不过只有元类同时也是 type 的子类。搞清楚这句话，意思就是，**元类是 type 类的子类**。使用 metaclass 关键字的类并不是type 的子类。

```python
class ClassOne(type):  # 这个是元类
    pass

class ClassTwo(metaclass=type):  # 不是元类，是用元类创建的类
    pass

class ClassThree(object, metaclass=type):   # 与ClassTwo一模一样。不是元类，是用元类创建的类
    pass

class ClassFour(ClassOne):  # 继承自元类，是元类
    pass

print(ClassOne.__mro__)
print(ClassTwo.__mro__)
print(ClassThree.__mro__)
print(ClassFour.__mro__)
```

```css
(<class '__main__.ClassOne'>, <class 'type'>, <class 'object'>)
(<class '__main__.ClassTwo'>, <class 'object'>)
(<class '__main__.ClassThree'>, <class 'object'>)
(<class '__main__.ClassFour'>, <class '__main__.ClassOne'>, <class 'type'>, <class 'object'>)
```

一定要搞清继承自 type 和使用 metaclass 关键字的不同。前者是元类，后者是由元类创建的类。

### 类装饰器的运行

为什么要讲类装饰器？因为类装饰器能以较简单的方式做到需要使用元类去做的事情 ——创建类时定制类。

类装饰器与函数装饰器非常类似，是参数为类对象的函数，返回原来的类或修改后的类。我们先来看代码，你可以尝试写一写答案：

```python
"""
请问代码中print语句的打印顺序？
"""
def deco_alpha(cls):
    print('<[200]> deco_alpha')

    def inner_1(self):
        print('<[300]> deco_alpha:inner_1')

    cls.method_y = inner_1
    return cls

@deco_alpha
class ClassThree():
    print('<[7]> ClassThree body')

    def method_y(self):
        print('<[8]> ClassThree.method_y')


if __name__ == '__main__':
    print('<[12]> ClassThree tests', 30 * '.')
    three = ClassThree()
    three.method_y()
```

```css
<[7]> ClassThree body		# MetaAleph 类的定义体运行了
<[200]> deco_alpha			# 装饰器函数运行了
<[12]> ClassThree tests ......
<[300]> deco_alpha:inner_1	# 装饰器覆盖了原有 MetaAleph 类的 method_y
```

先运行了被装饰的类 ClassThree 的定义体，然后运行装饰器函数，装饰器函数覆盖了原有 MetaAleph 类的 method_y 方法。 

**类装饰器有个重大缺点：只对直接依附的类有效。**  如果我们新增一个 ClassThree 的子类 ClassFour：

```python
"""
请问代码中print语句的打印顺序？
"""
def deco_alpha(cls):
    print('<[200]> deco_alpha')

    def inner_1(self):
        print('<[300]> deco_alpha:inner_1')

    cls.method_y = inner_1
    return cls

@deco_alpha
class ClassThree():
    print('<[7]> ClassThree body')

    def method_y(self):
        print('<[8]> ClassThree.method_y')

class ClassFour(ClassThree):
    print('<[9]> ClassFour body')

    def method_y(self):
        print('<[10]> ClassFour.method_y')

if __name__ == '__main__':
    print('<[12]> ClassThree tests', 30 * '.')
    three = ClassThree()
    three.method_y()
    print('<[13]> ClassFour tests', 30 * '.')
    four = ClassFour()
    four.method_y()
```

```css
<[7]> ClassThree body
<[200]> deco_alpha
<[9]> ClassFour body
<[12]> ClassThree tests ..............................
<[300]> deco_alpha:inner_1
<[13]> ClassFour tests ..............................
<[10]> ClassFour.method_y
```

类装饰器可能对子类没有影响。我们把 ClassFour 定义为 ClassThree 的子类，但是发现 ClassFour 的 method_y 方法并没有被覆盖。ClassThree 类上依附的 @deco_alpha 装饰器把 method_y 方法替换掉了，但是这对 ClassFour 类根本没有影响。当然，如果 ClassFour.method_y 方法使用 super(...) 调用 ClassThree.method_y 方法，我们便会看到装饰器起作用，执行 inner_1 函数。 

**类装饰器的缺点就是一次只定制一个类， 而不是定制整个类层次结构。**而元类就是为了解决这个缺点的，元类可以定制整个类层次结构。

### 元类的运行

元类可以定制整个类层次结构。我们先看看代码，代码中 print 的语句较多，结构其实并不复杂，尝试写一写答案：

```python
"""
请问代码中print语句的打印顺序？
"""
class MetaAleph(type):
    print('<[400]> MetaAleph body')

    def __init__(cls, name, bases, dic):
        print('<[500]> MetaAleph.__init__')

        def inner_2(self):
            print('<[600]> MetaAleph.__init__:inner_2')

        cls.method_z = inner_2

print('<a> ClassFive Before')
class ClassFive(metaclass=MetaAleph):
    print('<[6]> ClassFive body start')

    def __init__(self):
        print('<[7]> ClassFive.__init__')

    def method_z(self):
        print('<[8]> ClassFive.method_y')

    print('<[11]> ClassFive body end')

print('<c> ClassSix Before')
class ClassSix(ClassFive):
    print('<[9]> ClassSix body start')

    def method_z(self):
        print('<[10]> ClassSix.method_y')
    print('<[12]> ClassSix body end')

if __name__ == '__main__':
    print('<[13]> ClassFive tests', 30 * '.')
    five = ClassFive()
    five.method_z()
    print('<[14]> ClassSix tests', 30 * '.')
    six = ClassSix()
    six.method_z()
```

```python
<[400]> MetaAleph body
<a> ClassFive Before
<[6]> ClassFive body start
<[11]> ClassFive body end
<[500]> MetaAleph.__init__
<c> ClassSix Before
<[9]> ClassSix body start
<[12]> ClassSix body end
<[500]> MetaAleph.__init__
<[13]> ClassFive tests ..............................
<[7]> ClassFive.__init__
<[600]> MetaAleph.__init__:inner_2
<[14]> ClassSix tests ..............................
<[7]> ClassFive.__init__
<[600]> MetaAleph.__init__:inner_2
```

ClassSix 类没有直接引用 MetaAleph 类，但是却受到了影响，因为它是 ClassFive 的子类，进而也是 MetaAleph 类的实例，所以由 `MetaAleph.__init__` 方法初始化。 这就是元类的作用了。

### 理解元类的四个参数

```css
Python 解释器运行到 ClassFive 类的定义体时没有调用 type 构建具体的类定义体，而是调用 MetaAleph 类。看一下示例中定义的 MetaAleph 类，你会发现 __init__ 方法有四个参数。
> cls
这是要初始化的类对象（例如 ClassFive）。
> name、bases、dic
与构建类时传给 type 的参数一样。

记得这串代码吗？ type 的三个参数 name、bases、dic ：
Child = type('Child', (Person,), {'ClassName': ClassName,
                                      '__init__': __init__,
                                      'speak': speak})
```

### 元类中的 init 、call、new 方法
