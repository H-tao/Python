### 2. 协程的基本操作和四种状态

协程有四种状态，可以使用inspect.getgeneratorstate()确定协程状态：

- ‘GEN_CREATED'：等待开始执行。
- 'GEN_RUNNIGN'：正在执行。
- 'GEN_SUSPENDED'：在yield表达式处暂停。
- 'GEN_CLOSED'：执行结束。

协程（生成器）有四种跟调用方交互的方法()：

- next()：激活协程（生成器）。执行到第一个yield处暂停，将控制权交给调用方，使协程变为‘GEN_CREATED'状态。
- send()：发送数据给协程（生成器），发送的数据会成为yield表达式的值。这一步必须在协程变为‘GEN_CREATED'状态之后使用，也就是必须先使用next()或send(None)激活协程。
- throw()：使协程（生成器）在暂停的yield处抛出指定的异常。
- close()：终止协程（生成器）。使协程（生成器）在暂停的yield处抛出GeneratorExit异常。

我们看一个例子，使用这四种交互方法，并查看生成器的状态：

```javascript
from inspect import getgeneratorstate	# 导入获取生成器状态的包

class DemoException(Exception):	# 自定义一个异常
    pass

def demo3():
    print('start')
    while True:
        try:
            x = yield
        except DemoException:
            print("demo3 Received DemoException!")
        else:
            print("demo3 Received: ", x)
    # print('end')    # 这一行代码永远不会被执行
```

1. next() 或者 send(None) 预激协程：

```javascript
>>> c = demo3()
>>> next(c)   # 执行第一个yield，暂停
start
>>> getgeneratorstate(c)
'GEN_SUSPENDED'
>>> 
>>> c = demo3()
>>> c.send(None)
start
>>> getgeneratorstate(c)
'GEN_SUSPENDED'
```

2. send()

```javascript
>>> c.send(1)
demo3 Received:  1
>>> c.send(2)
demo3 Received:  2
>>> getgeneratorstate(c)
'GEN_SUSPENDED'
```

3. throw()

```javascript
>>> c.throw(DemoException)	# 调用方丢一个DemoException异常给协程，协程内定义了DemoException的处理方式
demo3 Received DemoException!
>>> getgeneratorstate(c)	
'GEN_SUSPENDED'
>>> 
>>> c.throw(ValueError)		# 调用方丢一个ValueError异常给协程，协程内未定义处理方式
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 5, in demo3
ValueError	# 协程将异常返回给调用方
>>> getgeneratorstate(c)	# 没办法处理异常会使协程状态变为closed
'GEN_CLOSED'
```

4. close()

```javascript
>>> c = demo3()
>>> c.close()
>>> getgeneratorstate(c)
'GEN_CLOSED'
```

我们不能在协程内捕获GeneratorExit异常，否则协程会抛出一个RuntimeError：

```javascript
def demo3():
    print('start')
    while True:
        try:
            x = yield
        except GeneratorExit:		# 尝试捕获GeneratorExit异常
            print("demo3 Received GeneratorExit!")
        else:
            print("demo3 Received: ", x)
```

```javascript
>>> c = demo3()
>>> next(c)
start
>>> c.send(1)
demo3 Received:  1
>>> c.close()
demo3 Received GeneratorExit!
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
RuntimeError: generator ignored GeneratorExit
```

如果想在协程结束时做某些事，可以使用`try...finally...`包裹协程：

```javascript
def demo3():
    print('start')
    try:
        while True:
            x = yield
            print("demo3 Received: ", x)
    finally:
        print('end')
```
```javascript
>>> c = demo3()
>>> next(c)
start
>>> c.send(1)
demo3 Received:  1
>>> c.close()
end				# 调用close()后，输出了end
```

### 3. 协程FAQ

一问：**协程跟生成器是什么关系？**

协程是生成器的一种，协程是一种控制流程，四种交互方法本质就是调用方跟生成器交互，因为生成器函数返回的就是生成器，而协程也是由生成器函数返回的。

二问：**为什么要先使用next()预激活协程？**

说了协程是一种控制流程。假如你雇了一个人给你装修房子，你愿意在你还没允许的情况下这个人就开始装修吗？所以，调用方得先使用next()告诉协程，我要你准备开始跑了，你才能开始。

### 4. 使用协程实现闭包

普通的闭包：我们定义一个嵌套函数来实现数据的加和，外层函数定义一个total变量来记录前面的和：

```javascript
def add():
    total = 0.0
    def calculate(x):
        nonlocal total
        total += x
        return total
    return calculate

a = add()
print(a(1))	# 1.0
print(a(2))	# 3.0
print(a(3))	# 6.0
```

使用协程：

```javascript
def add():
    total = 0.0
    while True:
        term = yield total
        total += term
```

```javascript
>>> a = add()
>>> next(a)     # 调用next函数，预激协程
0.0
>>> a.send(1)   # 多次调用send()，计算总和
1.0
>>> a.send(2)   # 多次调用send()，计算总和
3.0
>>> a.send(3)   # 多次调用send()，计算总和
6.0
>>>
```

### 5. 让协程返回值

我们想让协程跟普通函数一样，通过return返回值给我们。首先抛出一个疑问，既然调用方可以通过yield接收协程返回的值，我们为什么还要让协程返回值通过return返回值给我们呢？这是因为很多协程不会通过yield产出值，而是在最后返回一个值（比如累计值）。改写上面的累加函数：

```javascript
def add():
    total = 0.0
    while True:
        term = yield		# yield不再产出值
        if term is None:	# 让协程接收None时结束while True循环
            break
        total += term
    return {'total': total}
```

```javascript
>>> a = add()
>>> next(a)
>>> a.send(1)
>>> a.send(2)
>>> a.send(3)
>>> a.send(None)	# send(None)使协程结束while
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration: {'total': 6.0}	# 抛出了StopIteration
```

为什么会抛出StopIteration？生成器结束的时候就会抛出StopIteration，如果还不理解，请回去看生成器的内容。

我们可以使用try...except...捕获这个StopIteration：

```javascript
>>> a = add()
>>> next(a)
>>> a.send(1)
>>> a.send(2)
>>> a.send(3)
>>> try:
...     a.send(None)
... except StopIteration as e:
...     result = e.value
...
>>> result
{'total': 6.0}
```

### 6. yield from

```javascript
def add():
    total = 0.0
    while True:
        term = yield
        if term is None:
            break
        total += term
    return {'total': total}

def grouper(result):
    _a = add()
    next(_a)
    while True:
        x = yield
        try:
            _a.send(x)
        except StopIteration as e:
            res = e.value
            result.append(res)
            # return res        # 为什么不返回？
            
if __name__ == '__main__':
    result = []
    g = grouper(result)
    next(g)
    g.send(1)
    g.send(2)
    g.send(3)
    g.send(None)
    print(result)
```

```css
[{'total': 6.0}]
```

很多文章博客，都没有讲到为什么委派生成器grouper不使用返回值，我在这里讲一下自己的理解：

```
因为grouper也是一个生成器函数，如果返回，则会抛出StopIteration，我们又需要在外部处理StopIteration。而如果不返回，grouper会暂停在yield处，同时，调用方可以使用可变对象获取子生成器add的值，注意，一定是可变对象。
```

使用yield from简化代码：

```javascript
def grouper(result):
    while True:
        res = yield from add()
        result.append(res)
```

yield from帮我们完成了两件事，第一，预激活协程，第二，捕获StopIteration的返回值。

### 未解决的问题：使用async和await改写yield from报错

```javascript
def add():
    total = 0.0
    while True:
        term = yield
        if term is None:
            break
        total += term
    return {'total': total}

async def grouper(result):
    while True:
        f = await add()
        result.append(f)
    # return f
    
if __name__ == '__main__':
    result = []
    g = grouper(result)
    next(g)
    g.send(1)
    g.send(2)
    g.send(3)
    g.send(None)
    print(result)
```

```css
Traceback (most recent call last):
  File "D:/Desktop/Projects/autooperator/CodeCD/Pipelines/other.py", line 41, in <module>
    next(g)
TypeError: 'coroutine' object is not an iterator
sys:1: RuntimeWarning: coroutine 'grouper' was never awaited
```



